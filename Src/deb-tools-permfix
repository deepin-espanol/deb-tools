#!/bin/sh

Fmt='printf'
set -f
IFS="
"

CURLANG="${LANGUAGE%%_*}" # Get locale.

NOT_A_DEB="Error: '%s' is not a valid .deb file."
FOUND_DEB="Analysing '%s'."
LOOKING_DEB="Looking for .deb files in '%s'..."
DOESNT_EXIST="'%s' does not exist."
ISSUE_R="R: Files or folders with an owner other than 'root'."
ISSUE_W="W: Files or folders that can be written to by anyone."
ISSUE_C="C: Package extracts files or folders to unusual locations."

case "$CURLANG" in
es)
	NOT_A_DEB="Error: «%s» no es archivo .deb válido."
	FOUND_DEB="Analizando «%s»."
	LOOKING_DEB="Buscando archivos .deb en «%s»..."
	DOESNT_EXIST="«%s» no existe."
	ISSUE_R="R: Archivos o carpetas con un propietario distinto de «root»."
	ISSUE_W="E: Archivos o carpetas en los que puede escribir cualquiera."
	ISSUE_C="C: El paquete extrae archivos o carpetas a ubicaciones inusuales."
	;;
esac

PARAMETRO=""
LOCATION=""
INTERACTIVE_MODE=false

WantToContinue() {
	KEYBOARD=""
	CONTINUE=true
	while [ $CONTINUE = true ]; do
		echo
		$Fmt -- '─%.0s' $(seq "$(tput cols)")
		echo
		$Fmt "¿Desea continuar con el proceso de reempaquetado\? (s/N)"
		read -r KEYBOARD

		if [ "$KEYBOARD" = "" ]; then
			KEYBOARD="N"
		fi

		case $KEYBOARD in
		S | s)
			CONTINUE=false
			;;
		N | n)
			CONTINUE=false
			exit 0
			;;
		*)
			echo Respuesta incorrecta
			;;
		esac
	done
}

Repackage() {
	echo "Iniciando reempaquetado"

	WORK_FOLDER="$HOME/deb-tools"
	REPACKED_FOLDER="${WORK_FOLDER}/repackaged"
	PACKAGE="$1"

	if [ ! "$PACKAGE" ]; then
		$Fmt "$DOESNT_EXIST\n" "$PACKAGE"
		return 1
	fi

	LIST_QUITAR_ESCRITURA_OTROS="$2"
	INFO_PACKAGE=$(dpkg-deb -f "$PACKAGE" package version architecture | cut -d " " -f2)
	NAME_PACKAGE=$(echo "$INFO_PACKAGE" | cut -d " " -f1)
	VER_PACKAGE=$(echo "$INFO_PACKAGE" | cut -d " " -f2)
	ARCH_PACKAGE=$(echo "$INFO_PACKAGE" | cut -d " " -f3)

	REPACKED="${NAME_PACKAGE}_${VER_PACKAGE}_${ARCH_PACKAGE}"
	BUILD_FOLDER="${REPACKED_FOLDER}/${REPACKED}"

	mkdir -p "$WORK_FOLDER"
	mkdir -p "$REPACKED_FOLDER"

	if [ -d "$BUILD_FOLDER" ]; then
		echo "Borrando carpeta $BUILD_FOLDER"
		rm -rf "$BUILD_FOLDER"
	fi

	echo "Creando $BUILD_FOLDER"
	mkdir "$BUILD_FOLDER"

	echo "Extrayendo paquete $PACKAGE"
	dpkg-deb -R "$PACKAGE" "$BUILD_FOLDER"

	if [ "$LIST_QUITAR_ESCRITURA_OTROS" ]; then
		echo "Quitando permisos de escritura a «otros» de los siguientes archivos"

		for i in $LIST_QUITAR_ESCRITURA_OTROS; do
			chmod o-w "${BUILD_FOLDER}${i}"
			echo "${i}"
		done
	fi

	echo "Iniciando fakeroot"
	fakeroot echo "Estableciendo propietario y grupo «root» a '$BUILD_FOLDER'..."
	fakeroot chown -R root:root "$BUILD_FOLDER"
	fakeroot dpkg-deb --build "$BUILD_FOLDER" "$REPACKED_FOLDER"
	echo "fakeroot terminado"

	echo "Borrando $BUILD_FOLDER"
	rm -rf "$BUILD_FOLDER"

	echo "Reempaquetado $REPACKED en $REPACKED_FOLDER/$REPACKED.deb"
}

AnalyseDeb() {
	FILE=$*
	ISSUES=false

	if ! dpkg-deb --info "$FILE" >/dev/null 2>&1; then # It is not a valid .deb file!
		$Fmt >&2 "$NOT_A_DEB\n" "$FILE"
		return 1
	fi

	echo
	$Fmt -- '─%.0s' $(seq "$(tput cols)")
	echo
	$Fmt "$FOUND_DEB\n" "$FILE"
	dpkg-deb -f "$FILE" package version architecture

	COMPLEX=false
	PROPS_NO_ROOT=false
	OTHERS_WRITING=false

	LIST=$(dpkg-deb --contents "$FILE")
	LIST_COMPLEX=$(echo "$LIST" | grep -Ev " ./bin/| ./etc/| ./lib/| ./opt/| ./sbin/| ./usr/| ./tmp/| ./var/tmp/| ./$")
	LIST_NO_ROOT=$(echo "$LIST" | grep -Ev " root/root | 0/0 ")
	LIST_OTHERS_WRITING=$(echo "$LIST" | grep -E "^(d|-).......w. ")
	LIST_OTHERS_WRITING_SIMPLE=""

	if [ "$LIST_NO_ROOT" ]; then
		PROPS_NO_ROOT=true
		ISSUES=true
		echo "$ISSUE_R"
	fi

	if [ "$LIST_OTHERS_WRITING" ]; then
		OTHERS_WRITING=true
		ISSUES=true
		LIST_OTHERS_WRITING_SIMPLE="$(echo "$LIST_OTHERS_WRITING" | tr -s '[:blank:]' | cut -d " " -f 6-20 | sed "s|^./||")"
		echo "$ISSUE_W"
	fi

	if [ "$LIST_COMPLEX" ]; then
		COMPLEX=true
		echo "$ISSUE_C"
	fi

	if [ $INTERACTIVE_MODE = true ]; then
		if [ $COMPLEX = true ]; then
			KEYBOARD=""
			CONTINUE=true
			while [ $CONTINUE = true ]; do
				echo
				$Fmt -- '─%.0s' $(seq "$(tput cols)")
				echo
				$Fmt "Se encontraron archivos que se extraen en ubicaciones inusuales"
				$Fmt "¿Desea verlos\? (S/n)"
				read -r KEYBOARD

				if [ "$KEYBOARD" = "" ]; then
					KEYBOARD="S"
				fi

				case $KEYBOARD in
				S | s)
					echo "$LIST_COMPLEX" | less
					CONTINUE=false
					;;
				N | n)
					CONTINUE=false
					;;
				*)
					echo Respuesta incorrecta
					;;
				esac
			done
			WantToContinue
		fi

		if [ $PROPS_NO_ROOT = true ]; then
			KEYBOARD=""
			CONTINUE=true
			while [ $CONTINUE = true ]; do
				echo
				$Fmt -- '─%.0s' $(seq "$(tput cols)")
				echo
				$Fmt "Se encontraron archivos con propietario y grupo diferente a «root»"
				$Fmt "¿Desea verlos\? (S/n)"
				read -r KEYBOARD

				if [ "$KEYBOARD" = "" ]; then
					KEYBOARD="S"
				fi

				case $KEYBOARD in
				S | s)
					echo "$LIST_NO_ROOT" | less
					CONTINUE=false
					;;
				N | n)
					CONTINUE=false
					;;
				*)
					echo Respuesta incorrecta
					;;
				esac
			done
			WantToContinue
		fi

		if [ $OTHERS_WRITING = true ]; then
			KEYBOARD=""
			CONTINUE=true
			while [ $CONTINUE = true ]; do
				echo
				$Fmt -- '─%.0s' $(seq "$(tput cols)")
				echo
				$Fmt "Se encontraron archivos que permiten que «otros» escriban en ellos"
				$Fmt "¿Desea verlos\? (S/n)"
				read -r KEYBOARD

				if [ "$KEYBOARD" = "" ]; then
					KEYBOARD="S"
				fi

				case $KEYBOARD in
				S | s)
					echo "$LIST_OTHERS_WRITING" | less
					CONTINUE=false
					;;
				N | n)
					CONTINUE=false
					;;
				*)
					echo Respuesta incorrecta
					;;
				esac
			done

			KEYBOARD=""
			CONTINUE=true
			while [ $CONTINUE = true ]; do

				echo
				$Fmt -- '─%.0s' $(seq "$(tput cols)")
				echo
				$Fmt "¿Desea quiere quitar los permisos de escritura a «otros» de esos archivos\? (S/n)"
				read -r KEYBOARD

				if [ "$KEYBOARD" = "" ]; then
					KEYBOARD="S"
				fi

				case $KEYBOARD in
				S | s)
					CONTINUE=false
					;;
				N | n)
					# Vaciar la lista de archivos
					LIST_OTHERS_WRITING_SIMPLE=""
					CONTINUE=false
					;;
				*)
					echo Respuesta incorrecta
					;;
				esac
			done
			WantToContinue
		fi
	fi

	if [ $ISSUES = true ]; then
		Repackage "$FILE" "$LIST_OTHERS_WRITING_SIMPLE"
	else
		echo No se encontraron problemas de permisos
	fi

	return 0
}

LocateDebs() {
	$Fmt "$LOOKING_DEB\n" "$@"
	LIST_FILES=$(find "$@" -type f -iname "*.deb")

	for i in $LIST_FILES; do
		AnalyseDeb "$i"
	done

	return 0
}

case $# in
0)
	echo No se encontraron parámetros, especifique un archivo .deb o una carpeta
	exit 0
	;;
1)
	LOCATION=$1
	;;
2)
	PARAMETRO=$1
	LOCATION=$2

	case $PARAMETRO in
	-i)
		INTERACTIVE_MODE=true
		;;
	*)
		echo "El parámetro «$PARAMETRO» no es válido."
		exit 1
		;;
	esac
	;;
*)
	echo "Especifique sólo un archivo a la vez"
	exit 1
	;;
esac

if [ -f "$LOCATION" ]; then
	AnalyseDeb "$LOCATION"
elif [ -d "$LOCATION" ]; then
	LocateDebs "$LOCATION"
else
	$Fmt "$DOESNT_EXIST\n" "$i"
fi

set +f
unset IFS

exit 0
